[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spotify-Analyse Dokumentation",
    "section": "",
    "text": "Vorwort\nDie Art und Weise wie wir Musik konsumieren hat sich in den letzten Jahren grundlegend geändert. Anstatt CDs und MP3-Player haben die meisten Menschen heute ein Abonnement bei einem Musikstreamingdienst. Dabei stellt sich die Frage, was ein Song braucht, um bei einem Streamingdienst Erfolg zu haben.\n\nDieses Projekt wurde mit der Absicht ins Leben gerufen, diese Frage zu beantworten. Dafür wurde ein Datensatz, der meist-gestreamtesten Songs im Jahre 2023, anhand verschiedener Merkmale analysiert, um eine Geheimformel für einen erfolgreichen Song zu finden. In der Folgenden Dokumentation werde ich den Weg beschreiben, von der Beschaffung und Vorberereitung der Daten über die Erstellung detaillierter Visualisierungen mit Altair bis hin zur Entwicklung eines interaktiven Dashboards mit Streamlit. Dabei werde ich nicht nur auf die technsichen Heruasforderungen und die Lösungen derer eingehen, sondern auch die Ergebnisse klar darstellen.\n\nFalls Sie meine Ergebnisse anhand von einer Präsentation oder einem interaktiven Dashboard haben wollen, finden Sie diese unter den folgenden Links:\n\nPräsentation\nDashboard"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\nLink zum Dashboard."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "toc.html",
    "href": "toc.html",
    "title": "Inhaltsverzeichnis",
    "section": "",
    "text": "Einführung\n\n1.1 Projektübersicht\n1.2 Motivation\n\nDatensatz und Datenbeschaffung\n\n2.1 Quelle des Datensatzes\n2.2 Datenstruktur\n\nDatenvorbereitung\n\n3.1 Genutzte Bibliotheken\n3.2 Datensatz einlesen\n3.3 Datentypkonvertierung\n\n3.3.1 Ganzzahlkonvertierung\n3.3.2 Kategorische Konvertierung\n\n3.4 Umgang mit fehlenden Daten\n3.5 Bereinigung des Datensatzes\n3.6 Speichern des bereinigten Datensatzes\n\nAnalyse und Visualisierung\n\n3.1 Werkzeuge und Techniken\n3.2 Entwickelte Visualisierungen\n3.3 Analyseergebnisse\n\nErstellung des Interaktiven Dashboards\n\n4.1 Dashboard-Design\n4.2 Nutzererfahrung\n\nHerausforderungen und Lösungen\n\n5.1 Begegnete Probleme\n5.2 Angewandte Lösungen\n\nFazit und Reflexion\n\n6.1 Projektergebnisse\n6.2 Reflexion"
  },
  {
    "objectID": "intro.html#projektübersicht",
    "href": "intro.html#projektübersicht",
    "title": "1  Einführung",
    "section": "1.1 Projektübersicht",
    "text": "1.1 Projektübersicht\nDas Ziel dieses Projekts ist es, wie im Vorwort schon erwähnt, durch die Analyse der meistgestreamtesten Songs des Jahres 2023 Einblicke in die aktuellen Trends der Musik zu bekommen und daraus möglicherweise eine Geheimformel für einen Hit abzuleiten. Außerdem sollen diese Informationen auch visuell ansprechend dargestellt werden, unter der Verwendung von Datenvisualisierungstools wie Altair. Diese Information eignet sich besonders für Label-Chefs oder Musiker."
  },
  {
    "objectID": "intro.html#motivation",
    "href": "intro.html#motivation",
    "title": "1  Einführung",
    "section": "1.2 Motivation",
    "text": "1.2 Motivation\nDie Motivation für dieses Projekt ergab sich bei mir durch meine Begeisterung für Musik. Ich habe mir oft Fragen gestellt, welche Merkmale einen erfolgreichen Song ausmachen. Dieses Projekt zielt also darauf ab, die Verbindung zwischen Daten und musikalischer Ausdruckskraft zu erforschen."
  },
  {
    "objectID": "datensatz.html#quelle-des-datensatzes",
    "href": "datensatz.html#quelle-des-datensatzes",
    "title": "2  Datensatz und Datenbeschaffung",
    "section": "2.1 Quelle des Datensatzes",
    "text": "2.1 Quelle des Datensatzes\nDer verwendete Datensatz für die Analyse der meistgestreamten Spotify Songs 2023 wurde von Kaggle bezogen, einer Plattform, die eine breite Palette von Datensätzen für Datenwissenschaftsprojekte zur Verfügung stellt.\n\nDatensatz"
  },
  {
    "objectID": "datensatz.html#datenstruktur",
    "href": "datensatz.html#datenstruktur",
    "title": "2  Datensatz und Datenbeschaffung",
    "section": "2.2 Datenstruktur",
    "text": "2.2 Datenstruktur\nDer Datensatz umfasst insgesamt 943 Zeilen, wobei jede Zeile einen einzigartigen Song repräsentiert. Folgende Attribute sind für jeden Song erfasst:\n\ntrack_name: Name des Songs\nartist(s)_name: Name(n) des/der Künstler(s)\nartist_count: Anzahl der an dem Song beteiligten Künstler\nreleased_year: Jahr der Veröffentlichung des Songs\nreleased_month: Monat der Veröffentlichung\nreleased_day: Tag der Veröffentlichung im Monat\nin_spotify_playlists: Anzahl der Spotify-Playlists, in denen der Song enthalten ist\nin_spotify_charts: Vorhandensein und Rang des Songs in den Spotify-Charts\nstreams: Gesamtzahl der Streams auf Spotify\nin_apple_playlists: Anzahl der Apple Music-Playlists, in denen der Song enthalten ist\nin_apple_charts: Vorhandensein und Rang des Songs in den Apple Music-Charts\nin_deezer_playlists: Anzahl der Deezer-Playlists, in denen der Song enthalten ist\nin_deezer_charts: Vorhandensein und Rang des Songs in den Deezer-Charts\nin_shazam_charts: Vorhandensein und Rang des Songs in den Shazam-Charts\nbpm: Beats pro Minute, Maß für das Tempo des Songs\nkey: Tonart des Songs\nmode: Modus des Songs (Dur oder Moll)\ndanceability_%: Prozentwert, der angibt, wie geeignet der Song zum Tanzen ist\nvalence_%: Positivität des musikalischen Inhalts des Songs\nenergy_%: Wahrgenommenes Energieniveau des Songs\nacousticness_%: Anteil akustischer Klänge im Song\ninstrumentalness_%: Anteil instrumentaler Inhalte im Song\nliveness_%: Vorhandensein von Elementen einer Live-Darbietung\nspeechiness_%: Anteil gesprochener Worte im Song"
  },
  {
    "objectID": "datenvorbereitung.html#genutzte-python-bibliotheken",
    "href": "datenvorbereitung.html#genutzte-python-bibliotheken",
    "title": "3  Datenvorbereitung",
    "section": "3.1 Genutzte Python-Bibliotheken",
    "text": "3.1 Genutzte Python-Bibliotheken\nFür die Datenvorbereitung wurde die Bibliothek pandas verwendet."
  },
  {
    "objectID": "datenvorbereitung.html",
    "href": "datenvorbereitung.html",
    "title": "3  Datenvorbereitung",
    "section": "",
    "text": "Die Datenvorbereitung stellt sicher, dass der Datensatz für die Analyse optimiert ist. Im Folgenden werden die spezifischen Schritte beschrieben, die zur Vorbereitung des Datensatzes der meistgestreamten Songs 2023 durchgeführt wurden.  Für die Datenvorbereitung wurde die python-Bibliothek pandas verwendet."
  },
  {
    "objectID": "datenvorbereitung.html#datentypkonvertierung",
    "href": "datenvorbereitung.html#datentypkonvertierung",
    "title": "3  Datenvorbereitung",
    "section": "3.1 Datentypkonvertierung",
    "text": "3.1 Datentypkonvertierung\nNachdem der Datensatz mit pandas als .csv Datei eingelesen worden ist, war es notwendig bestimmte Spalten in passendere Datentypen zu konvertieren.\n\n3.1.1 Ganzzahl-Konvertierung\nDie Spalten in_shazam_charts, streams, und in_deezer_playlists wurden in Ganzzahlen umgewandelt, um numerische Analysen zu erleichtern.\n\n\n3.1.2 Kategorische-Konvertierung\nDie Spalten key und mode wurden in kategorische Datentypen umgewandelt, um Analysen, die auf diesen musikalischen Eigenschaften basieren, zu vereinfachen."
  },
  {
    "objectID": "datenvorbereitung.html#umgang-mit-fehlenden-daten",
    "href": "datenvorbereitung.html#umgang-mit-fehlenden-daten",
    "title": "3  Datenvorbereitung",
    "section": "3.2 Umgang mit fehlenden Daten",
    "text": "3.2 Umgang mit fehlenden Daten\nFehlende Daten wurden identifiziert und durch das Entfernen der betroffenen Zeilen aus dem Datensatz behandelt.\n\nDiese sorgfältige Vorbereitung des Datensatzes schafft eine solide Grundlage für die weiterführende Analyse und hilft dabei, aussagekräftige Einsichten in die Trends und Muster der meistgestreamten Songs 2023 zu gewinnen."
  },
  {
    "objectID": "datenanreicherung.html#liste-mit-künstlernamen",
    "href": "datenanreicherung.html#liste-mit-künstlernamen",
    "title": "4  Datenanreicherung",
    "section": "4.1 Liste mit Künstlernamen",
    "text": "4.1 Liste mit Künstlernamen\nAus dem DataFrame der vorbereiteten Daten wurde eine Liste der Künstlernamen extrahiert, die für die Abfragen nach Länderinformationen verwendet wurde."
  },
  {
    "objectID": "datenanreicherung.html#funktion-zur-ermittlung-des-künstlerlandes",
    "href": "datenanreicherung.html#funktion-zur-ermittlung-des-künstlerlandes",
    "title": "4  Datenanreicherung",
    "section": "4.2 Funktion zur Ermittlung des Künstlerlandes",
    "text": "4.2 Funktion zur Ermittlung des Künstlerlandes\nEine Funktion wurde implementiert, um das Land eines Künstlers mit Hilfe der MusicBrainz API zu finden. Diese Funktion behandelt auch Fehler und Fälle, in denen kein Land gefunden wurde.\nDie Funktion find_artist_country dient dazu, das Land eines Künstlers zu ermitteln. Sie nutzt die MusicBrainz API, um die notwendigen Informationen abzurufen. Die Funktion geht dabei wie folgt vor:\n\nSetzen des User-Agent: Zuerst wird ein User-Agent für die MusicBrainz API gesetzt. Dies ist notwendig, um die Anfragen an die API zu authentifizieren.\nSuchanfrage an MusicBrainz: Die Funktion sucht nach dem übergebenen Künstlernamen. Es wird lediglich das erste Suchergebnis berücksichtigt (limit=1).\nRückgabe des Landes: Wenn ein Künstler gefunden wird, gibt die Funktion das Land des Künstlers zurück. Andernfalls wird \"Artist not found\" zurückgegeben.\nFehlerbehandlung: Im Falle eines Fehlers bei der Anfrage oder der Verarbeitung der Daten wird eine Fehlermeldung zurückgegeben.\n\n\n\"\"\"\ndef find_artist_country(artist_name):\n    mb.set_useragent(\"Artist_Country\", \"1.0\", contact=\"me@example.com\")\n    try:\n        result = mb.search_artists(artist=artist_name, limit=1)\n        if result['artist-list']:\n            artist = result['artist-list'][0]\n            country = artist['area']['name']\n            return country\n        else:\n            return \"Artist not found\"\n    except Exception as e:\n        return f\"Error: {e}\"\n\n\"\"\"\n\n'\\ndef find_artist_country(artist_name):\\n    mb.set_useragent(\"Artist_Country\", \"1.0\", contact=\"me@example.com\")\\n    try:\\n        result = mb.search_artists(artist=artist_name, limit=1)\\n        if result[\\'artist-list\\']:\\n            artist = result[\\'artist-list\\'][0]\\n            country = artist[\\'area\\'][\\'name\\']\\n            return country\\n        else:\\n            return \"Artist not found\"\\n    except Exception as e:\\n        return f\"Error: {e}\"\\n\\n'"
  },
  {
    "objectID": "datenanreicherung.html#anreicherung-des-datensatzes-mit-den-künstlerländern",
    "href": "datenanreicherung.html#anreicherung-des-datensatzes-mit-den-künstlerländern",
    "title": "4  Datenanreicherung",
    "section": "4.3 Anreicherung des Datensatzes mit den Künstlerländern",
    "text": "4.3 Anreicherung des Datensatzes mit den Künstlerländern\nDer Datensatz wurde mit den Ländern der Künstler angereichert, indem die zuvor definierte Funktion verwendet wurde, um das Land für jeden Künstler abzufragen und dem DataFrame hinzuzufügen. Das ganze habe ich mit einer for-Schleife realisiert.\n\n\"\"\"\nartist_country_list = []\n\nfor artist in artist_list:\nartist_country_list.append(find_artist_country(artist))\n\ndf['artist_country'] = artist_country_list\n\n\"\"\"\n\n\"\\nartist_country_list = []\\n\\nfor artist in artist_list:\\nartist_country_list.append(find_artist_country(artist))\\n\\ndf['artist_country'] = artist_country_list\\n\\n\"\n\n\nDa die Datenbank leider nicht alle Künstler kannte, kam es in manchen spalten zu Errors, diese habe ich im Anschluss entfernt.\n \nDiese Datenanreicherung ermöglicht nun eine geografische Analyse der Künstlerstandorte und unterstützt die visuelle Darstellung der globalen Verteilung der Top-Künstler. Darauf basierend ist nun eine Darstellung anhand einer Map möglich."
  },
  {
    "objectID": "datenexploration.html",
    "href": "datenexploration.html",
    "title": "5  Datenexploration",
    "section": "",
    "text": "6 Vorgehen\nDas Ziel dieser Analyse ist wie mehrfach schon erwähnt eine Art Geheimformel für ein erfolgreichen Song herauszufinden."
  },
  {
    "objectID": "datenexploration.html#ergebnisse-der-exploration",
    "href": "datenexploration.html#ergebnisse-der-exploration",
    "title": "5  Datenexploration",
    "section": "5.3 Ergebnisse der Exploration",
    "text": "5.3 Ergebnisse der Exploration\nWie in den Histogrammen und in der Heatmap zu sehen ist, haben viele Top-Songs ähnliche Merkmalsausprägungen. Besonders stechen diese rechtschiefen Verteilungen aus:\n\nspeechiness\ninstrumentalness\n\nAber auch die eher Normalverteilten Merkmale sollte man beachten:\n\nenergy\ndanceability\n\nAuch bei der Tonart und des keys konnte ich auffälligkeiten feststellen, Die meisten Top-Songs haben die Tonart Major und den Key C#\nDer Releasezeitpunkt sollte auch ordentlich durchdacht werden. Im Janaur und Mai werden die meisten Songs relesed im August wurden fast 3 mal weniger Songs released.\nEine weitere interessante Information ist, dass mit großem Abstand die meisten Top-künstler aus den USA kommen.\nMit diesen Erkenntnissen kann ich nun anprechende Visualisierungen gestalten, wie ich das gemacht habe erfahren Sie im nächsten Kapitel."
  },
  {
    "objectID": "datenexploration.html#vorgehen",
    "href": "datenexploration.html#vorgehen",
    "title": "5  Datenexploration",
    "section": "5.2 Vorgehen",
    "text": "5.2 Vorgehen\nDas Ziel dieser Analyse ist wie mehrfach schon erwähnt eine Art Geheimformel für einen erfolgreichen Song herauszufinden.\nDafür habe ich zuerst die Verteilung musikalischen Merkmale der meistgestreamtesten Songs auf Spotify angeschaut. Dies habe ich mit der python-Bibliothek seaborn gemacht, da es hierbei noch nicht um eine ansprechende Visualisierung geht und ich diese Darstellung mit seaborn leichter finde als mit altair. In den folgenden Plots sind die Anzahl der Songs mit der jeweiligen Ausprägung des musikalischen Merkmals zu sehen. Als Maßstab habe ich hier die Anzahl der Songs genommen, da der Datensatz bereits die erfolgreichsten Songs im Jahre 2023 enthält.\n\n\n\nHistogramme anhand der musikalischen Merkmale\n\n\n\nUm trotzdem Auffälligkeiten zwischen der Anzahl der Streams und den musikalischen Merkmalen zu finden habe ich eine Hetmap erstellt. Diese enthält wie Sie unten sehen die einzelenen musikalischen merkmale und als label die Streams.\n\n\n\nHeatmap\n\n\n\nNatürlich habe ich mir auch noch die anderen Merkmale angschaut mithilfe der value_counts() builtin funktion von Pandas habe ich die Anzahl der Top-Songs nach der Tonart und des Keys angeschaut:\nTonart\n\n\n\nmode\nAnzahl der Top-Songs\n\n\n\n\nMajor\n445\n\n\nMinor\n351\n\n\n\nKey\n\n\n\nkey\nAnzahl der Top-Songs\n\n\n\n\nC#\n114\n\n\nG\n87\n\n\nG#\n85\n\n\nF\n81\n\n\nB\n76\n\n\nD\n74\n\n\nA\n71\n\n\nF#\n68\n\n\nE\n55\n\n\nA#\n55\n\n\nD#\n30\n\n\n\n\nDanach bin ich weg von den musikalischen Merkmalen und hin zu den zeitlichen und geografischen. Wann ist der beste Zeitpunkt ein Song zu releasen? Aus welchem land kommen die meisten Top-Künstler? Auch hier konnte ich mit der pandas builtin value_counts() wichtige erste Informationen sammeln:\nReleasezeipunkt\n\n\n\nreleased_month\nAnzahl der Top-Songs\n\n\n\n\n5\n112\n\n\n1\n112\n\n\n6\n75\n\n\n3\n69\n\n\n11\n66\n\n\n12\n63\n\n\n4\n62\n\n\n10\n58\n\n\n9\n48\n\n\n7\n47\n\n\n2\n45\n\n\n8\n39\n\n\n\nAnzahl der Künstler nach Künstlerland\n\n\n\nartist_country\nAnzahl der Künstler\n\n\n\n\nUnited States\n354\n\n\nPuerto Rico\n62\n\n\nUnited Kingdom\n57\n\n\nSouth Korea\n54\n\n\nCanada\n43\n\n\nColombia\n36\n\n\nEngland\n30\n\n\nMexico\n28\n\n\nBrazil\n16\n\n\nArgentina\n12"
  },
  {
    "objectID": "datenexploration.html#verwendete-werkzeuge-und-bibliotheken",
    "href": "datenexploration.html#verwendete-werkzeuge-und-bibliotheken",
    "title": "5  Datenexploration",
    "section": "5.1 Verwendete Werkzeuge und Bibliotheken",
    "text": "5.1 Verwendete Werkzeuge und Bibliotheken\nFür die Datenexploration habe ich verschiedene Bibliotheken verwendet. Für Korrelationsmatrizen und Histogramme habe ich die Python Visualisierungsbibliothek Seaborn benutzt, da ich mit dieser schon Vorkenntnisse hatte und es in der Datenexploration nur darum geht, Zusammenhänge zu finden und nicht um eine ansprechende Visualisierung. Des Weiteren habe ich pandas benutzt, um Auffälligkeiten zu finden.\nJedoch habe ich auch hier “Mockups“ von ersten, meines Erachtens wichtigen Erkenntnissen mit Altair erstellt. Darauf gehe ich aber erst im nächsten Kapitel ein."
  },
  {
    "objectID": "datenvisualisierung.html",
    "href": "datenvisualisierung.html",
    "title": "6  Datenvisualisierung",
    "section": "",
    "text": "7 Barplots"
  },
  {
    "objectID": "datenvisualisierung.html#grundelegendes-design",
    "href": "datenvisualisierung.html#grundelegendes-design",
    "title": "6  Datenvisualisierung",
    "section": "6.1 Grundelegendes Design",
    "text": "6.1 Grundelegendes Design\nUm ein durchgehendes Design zu ermöglichen habe ich zuerst Konfigurationsparameter für Altair Plots erstellt. Diese sind so gut wie gleich in den verschiedenen Diagrammtypen:\n\n\"\"\"\n.properties(\n    title={'text': 'Beispiel', 'dy': -20},\n    background='#F5F5F5',\n    width=600,\n    height=400\n).configure_title(\n    fontSize=25,\n    anchor='start'\n).configure_axis(\n    labelFontSize=14,\n    titleFontSize=20,\n    titleColor='gray',\n    labelColor='gray',\n    titlePadding=12,\n    grid=False\n).configure_legend(\n    titleFontSize=16,\n    labelFontSize=14\n).configure_view(\n    strokeWidth=0,\n).configure_axisX(\n    labelAngle=0,\n    titleAnchor='start'\n).configure_axisY(\n    titleAnchor='end'\n)\n\n\"\"\"\n\n\"\\n.properties(\\n    title={'text': 'Beispiel', 'dy': -20},\\n    background='#F5F5F5',\\n    width=600,\\n    height=400\\n).configure_title(\\n    fontSize=25,\\n    anchor='start'\\n).configure_axis(\\n    labelFontSize=14,\\n    titleFontSize=20,\\n    titleColor='gray',\\n    labelColor='gray',\\n    titlePadding=12,\\n    grid=False\\n).configure_legend(\\n    titleFontSize=16,\\n    labelFontSize=14\\n).configure_view(\\n    strokeWidth=0,\\n).configure_axisX(\\n    labelAngle=0,\\n    titleAnchor='start'\\n).configure_axisY(\\n    titleAnchor='end'\\n)\\n\\n\"\n\n\n\n6.1.1 Allgemeine Eigenschaften\n\n.properties(): Allgemeine Eigenschaften des Diagramms.\n\ntitle: Legt den Titel des Diagramms fest.\ndy definiert die vertikale Verschiebung\nbackground: Hintergrundfarbe des Diagramms.\nwidth: Bestimmt die Breite des Diagramms in Pixeln.\nheight: Bestimmt die Höhe des Diagramms in Pixeln.\n\n\n\n\n6.1.2 Titelkonfiguration\n\n.configure_title(): Anapssungen für den Diagrammtitel.\n\nfontSize: Die Schriftgröße des Titels in Pixeln.\nanchor: Die Ausrichtung des Titels.\n\n\n\n\n6.1.3 Achsenkonfiguration\n\n.configure_axis(): konfiguration für beide Achsen (X & Y).\n\nlabelFontSize: Schriftgröße der Achsenbeschriftungen.\ntitleFontSize: Schriftgröße des Achsentitels.\ntitleColor und labelColor: Die Farbe des Achsentitels und der Beschriftungen.\ntitlePadding: Der Abstand zwischen dem Achsentitel und den Achsenbeschriftungen.\ngrid: Steuert die Anzeige des Gitternetzes. False bedeutet, dass kein Gitternetz gezeigt wird.\n\n\n\n\n6.1.4 Legendenkonfiguration\n\n.configure_legend(): Passt das Aussehen der Legende an.\n\ntitleFontSize: Die Schriftgröße des Legendentitels.\nlabelFontSize: Die Schriftgröße der Legendenbeschriftungen.\n\n\n\n\n6.1.5 Ansichtskonfiguration\n\n.configure_view(): Konfiguation der Ansicht.\n\nstrokeWidth: Die Breite des Rahmens um das Diagramm. 0 bedeutet, dass kein Rahmen gezeigt wird.\n\n\n\n\n6.1.6 Spezifische Achsenkonfigurationen\n\n.configure_axisX() und .configure_axisY(): Spezifische Konfigurationen für die X- und Y-Achse.\n\nlabelAngle: Der Winkel der Achsenbeschriftungen auf der X-Achse. 0 bedeutet eine horizontale Ausrichtung.\ntitleAnchor: Die Ausrichtung des Achsentitels.\n\n\n\nBeachte: Die Hintergrundfarbe, Schriftgröße und die width und height können in späteren Darstellungen in der quarto-Präsentation oder in dem Dashboard variieren."
  },
  {
    "objectID": "datenvisualisierung.html#barplots",
    "href": "datenvisualisierung.html#barplots",
    "title": "6  Datenvisualisierung",
    "section": "6.2 Barplots",
    "text": "6.2 Barplots\nFür die Erstellung von Barplots haben sich meiner Meinung nach die Anzahl der Songs nach Tonart und Keys geeignet. Da man mit einem Barplot perfekt unterschiede in verschiedenen Kategorieren aufzeigen kann.\nTonart:\nDafür habe ich zuerst ein Barplot mit den zwei verschiedenen Tonarten auf der X-Achse Erstellt. Um den Unterschied besser aufzuzeigen, habe ich die Skalierung auf der Y-Achse geändert und eine Linie auf der Höhe des Maximalwerts plaziert. Das ganze habe ich mit der alt.layer() Funktion erreicht, die die Linie und den Plot layert.\n\n\n\nAnzahl der Top-Songs nach Tonart\n\n\nKeys:\nHierfür habe ich einen Barplot mit den verschiedenen Keys auf der X-Achse erstellt. Auch hier habe ich um den Unterschied besser aufzuzeigen, die Skalierung auf der Y-Achse geändert. Außerdem habe ich wieder eine Linie durch den Maximalwert gezogen und eine gestrichelte Linie durch den Minimalwert. Um dieses Linien und somit den Unterschied besser hervorzuheben, habe ich dem Barplot eine geringere opacity gegeben. Auch hier habe ich wieder mit alt.layer() gearbeitet.\n\n\n\nAnzahl der Ø Streams nach Key"
  },
  {
    "objectID": "datenvisualisierung.html#line-chart",
    "href": "datenvisualisierung.html#line-chart",
    "title": "6  Datenvisualisierung",
    "section": "6.3 Line-Chart",
    "text": "6.3 Line-Chart\nEin Linendiagramms ist ideal um die Anzajl der Song-veröffentlichungen pro Monat darzustellen, daes die zeitliche Entwicklung und Trends klar hervorhebt. es ermöglicht ein einfaches Erkennen von Mustern, wie z.B. saisonale Schwankungen oder Trends.\nFür die Erstellung dieses Diagramms, habe ich zuerst die release-Monate, die in dem Datensatz von 1-12 angegeben waren, auf die Monatsabkürzungen gemapped. Diese stellten bei mir dann die X-Achse dar, auf der Y-Achse war die Anzahl der veröffentlichten Songs in diesem Monat. Um die Unterschiede hervorzuheben, habe ich die Extremwerte mit Puknten und senkrechten gestrichelten Linien versehen. Dafür habe ich verschieden Plots erstellt und diese Dann mit alt.layer() zusammengefügt\n\n\n\nAnzahl der Veröffentlichungen nach Monat"
  },
  {
    "objectID": "datenvisualisierung.html#scatter-plot",
    "href": "datenvisualisierung.html#scatter-plot",
    "title": "6  Datenvisualisierung",
    "section": "6.4 Scatter-Plot",
    "text": "6.4 Scatter-Plot\nIch habe mich für ein Streudiagramm entschieden, um die Beziehung zwischen Speechiness und der Anzahl der Streams darzustellen, weil es mir ermöglicht, Muster und Korrelationen zwischen diesen Beiden Variablen zu erkennen. Dieser Plot veranschaulicht besonders gut, wie die Menge der gesprochenen Worte in einem Song (Speechiness) mit der Anzahl der erfolgreichen Songs mit diesem Speechiness-Wert zusammenhängt.\nUm diesen Scatter-Plot zu erstellen, habe ich zunächst die Daten nach der Speechiness Gruppiert und die Anzahl der Songs für jeden Speechniess-Wert gezählt. Danach habe ich Songs welche über 40% Speechiness haben aussortiert, um den Fokus auf den relevanten Bereich zu belassen. Anschließend habe ich diese gefilterten Daten benutzt um ein Lineares Regressionsmodell zu trainieren (sklearn). Diese Vorhersage habe ich dann in einem DataFrame gespeichert.\nDaraufhin habe ich mit Altair die Regressionslinie und den Scatter-Plot erstellt und diese wieder mit alt.layer() zusammengefügt. Um die regressionsLinie Hervorzuheben, habe ich die opacity des Scatter-Plots angepasst.\n\n\n\nBeziehung zwischen Anzahl der Songs und der Speechiness"
  },
  {
    "objectID": "datenvisualisierung.html#distribution-plot",
    "href": "datenvisualisierung.html#distribution-plot",
    "title": "6  Datenvisualisierung",
    "section": "6.5 Distribution-Plot",
    "text": "6.5 Distribution-Plot\nIch habe mich dazu entschieden Die Anzahl der Songs pro Energy-Kategorie in einem Verteilungsdiagramm darzustellen, weil es mir ermöglicht, die Verteilung und die zentrale Tendenz der Daten auf einen Blick zu erfassen. So kann ich erkennen, in welchen Energiebereichen die meisten Songs veröffentlicht werden, und eventuelle Ausreißer oder Trends sofort identifizieren.\nDafür habe ich zuerst die Energy-Werte Gruppiert und von 0-100 in 10 Kategorien aufgeteilt, mit der durchschnittlichen Anzahl der Songs pro Kategorie. Daraufhin habe ich nun 2 Charts erstellt ein Histogramm, was das Ergebnis in ‘Balkenform’ angibt un ein LinienDiagramm mit dem Prop interpolate='monotone' für eine glatte Linie.\nDiese Beiden Plots habe ich wieder mit der alt.layer() funktion Zusammengefügt und dem Histogramm etwas weniger opacity gegeben um die Linie etwas hervorzuheben.\n\n\n\nØ Anzahl der Songs nach Energy"
  },
  {
    "objectID": "datenvisualisierung.html#map",
    "href": "datenvisualisierung.html#map",
    "title": "6  Datenvisualisierung",
    "section": "6.6 Map",
    "text": "6.6 Map\nFür die Map habe ich die Geopandas Bibliothek verwendet, die sich sehr gut für die Verarbeitung von geografischen Daten eignet. Jedoch musste ich zuerst die von mir angereicherten Herkunftsländer in dem Datensatz mappen, da sie in der verwendeten Bibliothek zum Teil anders hießen. Danach habe ich die Anzahl der Künstler pro Land gezählt und in einem DataFrame gespeichert. Dann habe ich die Geopandas Daten und meinen DataFrame zusammegeführt, wobei ich die Anzahl der Künstler pro Land als zusätzlich Information hinzugefügt habe.\nMit Altair habe ich dann eine Map erstelt, und die Länder entsprechend ihrer Künstler-Anzahl eingefärbt. Da es einen Starken außreiser mit den USA gab, habe ich eine Logarithmische Skala verwendet um die Unterschiede Sichtbarer zu machen.\n\n\n\nAnzahl Top-Künstler nach Herkunftsland\n\n\n\nNun hatte ich die grundlegenden Charts erstellt und ich konnte mit der Erstellung der Präsentation und des Dashboards anfangen."
  },
  {
    "objectID": "quarto_prasi.html#desgin",
    "href": "quarto_prasi.html#desgin",
    "title": "7  Quarto Präsentation",
    "section": "7.1 Desgin",
    "text": "7.1 Desgin\nIch habe mich für ein Dunkles Design entschieden, dies habe ich mit dem frei verfügaberen theme “dark” erreichen können. Außerdem habe ich eine custom scss datei erstellt, in der ich die größen und das alignment der Überschriften und des Footers bestimmt habe:\nscss:\n\n\"\"\"\n\n/*-- scss:defaults --*/\n// Hier können Sie Standardwerte für Variablen definieren.\n\n/*-- scss:rules --*/\n// Hier schreiben Sie Ihre Haupt-Style-Regeln.\n.reveal {\n    h3 {\n        font-size: 70px;\n    }\n\n    h4 {\n        font-size: 40px;\n    }\n\n    h2 {\n        font-size: 100px;\n    }\n\n    h1 {\n        text-align: center;\n        font-size: 200px;\n    }\n\n\n\n    // Weitere Style-Regeln...\n}\n\n\n.footer {\n    text-align: left;\n}\n\n\n\n\"\"\"\n\n'\\n\\n/*-- scss:defaults --*/\\n// Hier können Sie Standardwerte für Variablen definieren.\\n\\n/*-- scss:rules --*/\\n// Hier schreiben Sie Ihre Haupt-Style-Regeln.\\n.reveal {\\n    h3 {\\n        font-size: 70px;\\n    }\\n\\n    h4 {\\n        font-size: 40px;\\n    }\\n\\n    h2 {\\n        font-size: 100px;\\n    }\\n\\n    h1 {\\n        text-align: center;\\n        font-size: 200px;\\n    }\\n\\n\\n\\n    // Weitere Style-Regeln...\\n}\\n\\n\\n.footer {\\n    text-align: left;\\n}\\n\\n\\n\\n'\n\n\nAußerdem habe ich die Breite für slides benutzerdefiniert angepasse, da ich wollte, dass die Diagramme immernoch angemessen angezeigt werden, wenn die slide in Columns aufgeteilt wird:\n\nBreite: 2000\nHöhe: 960\n\nUm eine Konsistenete Farbauswahl für die (Achsen-)Titel zu haben, die zu dem dunklen Hintergrund passt, habe ich Farben definiert:\n\nTitelfarbe: rgba(230, 230, 230, 0.7)\nY-Achse-Titel&Label: rgba(230, 230, 230, 0.5)\nX-Achse-Titel&Label: rgba(224, 224, 224, 0.3)"
  },
  {
    "objectID": "quarto_prasi.html#vorgehen",
    "href": "quarto_prasi.html#vorgehen",
    "title": "7  Quarto Präsentation",
    "section": "7.2 Vorgehen",
    "text": "7.2 Vorgehen\nNachdem das Design stand, habe ich meine Erstellten Visualisierungen, in die jeweiligen Slides eingebaut. In meinem Vorgehen habe ich zunächst die Base Charts ohne layering präsentiert und dabei die einzelnen Merkmale und Bestandteile des Diagramms erläutert. iM Anschluss dann mit Layering um auf die Ergebnisse besser einzugehen."
  }
]