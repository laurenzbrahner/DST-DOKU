[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spotify-Analyse Dokumentation",
    "section": "",
    "text": "Vorwort\nDie Art und Weise, wie wir Musik konsumieren, hat sich in den letzten Jahren grundlegend geändert. Anstatt CDs und MP3-Player haben die meisten Menschen heute ein Abonnement bei einem Musikstreamingdienst. Dabei stellt sich die Frage, was ein Song braucht, um bei einem Streamingdienst Erfolg zu haben.\n Dieses Projekt wurde mit der Absicht ins Leben gerufen, diese Frage zu beantworten. Dafür wurde ein Datensatz der meist-gestreamtesten Songs im Jahre 2023, anhand verschiedener Merkmale analysiert, um eine Geheimformel für einen erfolgreichen Song zu finden. In der folgenden Dokumentation werde ich den Weg beschreiben, von der Beschaffung und Vorbereitung der Daten, über die Erstellung detaillierter Visualisierungen mit Altair, bis hin zur Entwicklung eines interaktiven Dashboards mit Streamlit. Dabei werde ich nicht nur auf die technischen Herausforderungen und die Lösungen derer eingehen, sondern auch die Ergebnisse klar darstellen.\n\nFalls Sie meine Ergebnisse anhand einer Präsentation, einem interaktiven Dashboard oder meinem Report einsehen möchten, finden Sie diese unter den folgenden Links:\n\nPräsentation\nDashboard\nReport",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "toc.html",
    "href": "toc.html",
    "title": "Inhaltsverzeichnis",
    "section": "",
    "text": "Einführung\n\n1.1 Projektübersicht\n1.2 Motivation\n\nDatensatz und Datenbeschaffung\n\n2.1 Quelle des Datensatzes\n2.2 Datenstruktur\n\nDatenvorbereitung\n\n3.1 Datentypkonvertierung\n\n3.1.1 Ganzzahlkonvertierung\n3.1.2 Kategorische Konvertierung\n\n3.2 Umgang mit fehlenden Daten\n\nDatenanreicherung\n\n4.1 Funktion zur Ermittlung des Künstlerlandes\n4.2 Anreicherung des Datensatzes mit den Künstlerländern\n\nDatenexploration\n\n5.1 Verwendete Werkzeuge und Bibliotheken\n5.2 Vorgehen\n5.3 Ergebnisse der Exploration\n\nDatenvisualisierung\n\n6.1 Grundlegendes Design\n\n6.1.1 Allgemeine Eigenschaften\n6.1.2 Titelkonfiguration\n6.1.3 Achsenkonfiguration\n6.1.4 Legendenkonfiguration\n6.1.5 Ansichtskonfiguration\n6.1.6 Spezifische Achsenkonfigurationen\n\n6.2 Barplots\n6.3 Line-Chart\n6.4 Scatter-Plot\n6.5 Distribution-Plot\n6.6 Map\n\nQuarto Präsentation\n\n7.1 Design\n7.2 Vorgehen\n\nStreamlit Dashboard und Report\n\n8.1 Design, Aufbau und Beschreibung der Funktionalität des Dashboards\n8.2 Erstellung des Reports\n\nHerausforderungen und Lösungen\n\n9.1 Datensatz und geografische Daten\n9.2 Visualisierungen\n9.3 Quarto Präsentation\n9.4 Streamlit Dashboard\n\nFazit und Reflexion\n\n10.1 Projektergebnisse\n10.2 Reflexion",
    "crumbs": [
      "Inhaltsverzeichnis"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Einführung",
    "section": "",
    "text": "1.1 Projektübersicht\nDas Ziel dieses Projekts ist es, wie im Vorwort schon erwähnt, durch die Analyse der meistgestreamtesten Songs des Jahres 2023 Einblicke in die aktuellen Trends der Musik zu bekommen und daraus möglicherweise eine Geheimformel für einen Hit abzuleiten. Außerdem sollen diese Informationen auch visuell ansprechend dargestellt werden, unter der Verwendung von Datenvisualisierungstools wie Altair. Diese Information eignet sich besonders für Label-Chefs oder Musiker.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung</span>"
    ]
  },
  {
    "objectID": "intro.html#motivation",
    "href": "intro.html#motivation",
    "title": "1  Einführung",
    "section": "1.2 Motivation",
    "text": "1.2 Motivation\nDie Motivation für dieses Projekt ergab sich bei mir durch meine Begeisterung für Musik. Ich habe mich oft gefragt, welche Merkmale einen erfolgreichen Song ausmachen. Dieses Projekt zielt also darauf ab, die Verbindung zwischen Daten und musikalischem Erfolg zu erforschen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung</span>"
    ]
  },
  {
    "objectID": "datensatz.html",
    "href": "datensatz.html",
    "title": "2  Datensatz und Datenbeschaffung",
    "section": "",
    "text": "2.1 Quelle des Datensatzes\nDer verwendete Datensatz für die Analyse der meistgestreamten Spotify Songs 2023 wurde von Kaggle bezogen, einer Plattform, die eine breite Palette von Datensätzen für Datenwissenschaftsprojekte zur Verfügung stellt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datensatz und Datenbeschaffung</span>"
    ]
  },
  {
    "objectID": "datensatz.html#quelle-des-datensatzes",
    "href": "datensatz.html#quelle-des-datensatzes",
    "title": "2  Datensatz und Datenbeschaffung",
    "section": "",
    "text": "Datensatz",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datensatz und Datenbeschaffung</span>"
    ]
  },
  {
    "objectID": "datensatz.html#datenstruktur",
    "href": "datensatz.html#datenstruktur",
    "title": "2  Datensatz und Datenbeschaffung",
    "section": "2.2 Datenstruktur",
    "text": "2.2 Datenstruktur\nDer Datensatz umfasst insgesamt 943 Zeilen, wobei jede Zeile einen einzigartigen Song repräsentiert. Folgende Attribute sind für jeden Song erfasst:\n\ntrack_name: Name des Songs\nartist(s)_name: Name(n) des/der Künstler(s)\nartist_count: Anzahl der an dem Song beteiligten Künstler\nreleased_year: Jahr der Veröffentlichung des Songs\nreleased_month: Monat der Veröffentlichung\nreleased_day: Tag der Veröffentlichung im Monat\nin_spotify_playlists: Anzahl der Spotify-Playlists, in denen der Song enthalten ist\nin_spotify_charts: Vorhandensein und Rang des Songs in den Spotify-Charts\nstreams: Gesamtzahl der Streams auf Spotify\nin_apple_playlists: Anzahl der Apple Music-Playlists, in denen der Song enthalten ist\nin_apple_charts: Vorhandensein und Rang des Songs in den Apple Music-Charts\nin_deezer_playlists: Anzahl der Deezer-Playlists, in denen der Song enthalten ist\nin_deezer_charts: Vorhandensein und Rang des Songs in den Deezer-Charts\nin_shazam_charts: Vorhandensein und Rang des Songs in den Shazam-Charts\nbpm: Beats pro Minute, Maß für das Tempo des Songs\nkey: Tonart des Songs\nmode: Modus des Songs (Dur oder Moll)\ndanceability_%: Prozentwert, der angibt, wie geeignet der Song zum Tanzen ist\nvalence_%: Positivität des musikalischen Inhalts des Songs\nenergy_%: Wahrgenommenes Energieniveau des Songs\nacousticness_%: Anteil akustischer Klänge im Song\ninstrumentalness_%: Anteil instrumentaler Inhalte im Song\nliveness_%: Vorhandensein von Elementen einer Live-Darbietung\nspeechiness_%: Anteil gesprochener Worte im Song",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datensatz und Datenbeschaffung</span>"
    ]
  },
  {
    "objectID": "datenvorbereitung.html",
    "href": "datenvorbereitung.html",
    "title": "3  Datenvorbereitung",
    "section": "",
    "text": "3.1 Datentypkonvertierung\nNachdem der Datensatz mit pandas als .csv Datei eingelesen worden ist, war es notwendig bestimmte Spalten in passendere Datentypen zu konvertieren.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datenvorbereitung</span>"
    ]
  },
  {
    "objectID": "datenvorbereitung.html#datentypkonvertierung",
    "href": "datenvorbereitung.html#datentypkonvertierung",
    "title": "3  Datenvorbereitung",
    "section": "",
    "text": "3.1.1 Ganzzahl-Konvertierung\nDie Spalten in_shazam_charts, streams, und in_deezer_playlists wurden in Ganzzahlen umgewandelt, um numerische Analysen zu erleichtern.\n\n\n3.1.2 Kategorische-Konvertierung\nDie Spalten key und mode wurden in kategorische Datentypen umgewandelt, um Analysen, die auf diesen musikalischen Eigenschaften basieren, zu vereinfachen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datenvorbereitung</span>"
    ]
  },
  {
    "objectID": "datenvorbereitung.html#umgang-mit-fehlenden-daten",
    "href": "datenvorbereitung.html#umgang-mit-fehlenden-daten",
    "title": "3  Datenvorbereitung",
    "section": "3.2 Umgang mit fehlenden Daten",
    "text": "3.2 Umgang mit fehlenden Daten\nFehlende Daten wurden identifiziert und durch das Entfernen der betroffenen Zeilen aus dem Datensatz behandelt.\n\nDiese sorgfältige Vorbereitung des Datensatzes schafft eine solide Grundlage für die weiterführende Analyse und hilft dabei, aussagekräftige Einsichten in die Trends und Muster der meistgestreamten Songs 2023 zu gewinnen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datenvorbereitung</span>"
    ]
  },
  {
    "objectID": "datenanreicherung.html",
    "href": "datenanreicherung.html",
    "title": "4  Datenanreicherung",
    "section": "",
    "text": "4.1 Funktion zur Ermittlung des Künstlerlandes\nZuerst habe ich aus dem DataFrame der vorbereiteten Daten eine Liste der Künstlernamen extrahiert, die für die Abfragen nach Länderinformationen verwendet wurde. Anschließend habe ich eine Funktion implementiert, um das Land eines Künstlers mit Hilfe der MusicBrainz API zu finden. Diese Funktion behandelt auch Fehler und Fälle, in denen kein Land gefunden wurde.\nDie Funktion find_artist_country dient dazu, das Land eines Künstlers zu ermitteln. Sie nutzt die MusicBrainz API, um die notwendigen Informationen abzurufen. Die Funktion geht dabei wie folgt vor:\n\"\"\"\ndef find_artist_country(artist_name):\n    mb.set_useragent(\"Artist_Country\", \"1.0\", contact=\"me@example.com\")\n    try:\n        result = mb.search_artists(artist=artist_name, limit=1)\n        if result['artist-list']:\n            artist = result['artist-list'][0]\n            country = artist['area']['name']\n            return country\n        else:\n            return \"Artist not found\"\n    except Exception as e:\n        return f\"Error: {e}\"\n\n\"\"\"\n\n'\\ndef find_artist_country(artist_name):\\n    mb.set_useragent(\"Artist_Country\", \"1.0\", contact=\"me@example.com\")\\n    try:\\n        result = mb.search_artists(artist=artist_name, limit=1)\\n        if result[\\'artist-list\\']:\\n            artist = result[\\'artist-list\\'][0]\\n            country = artist[\\'area\\'][\\'name\\']\\n            return country\\n        else:\\n            return \"Artist not found\"\\n    except Exception as e:\\n        return f\"Error: {e}\"\\n\\n'",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Datenanreicherung</span>"
    ]
  },
  {
    "objectID": "datenanreicherung.html#funktion-zur-ermittlung-des-künstlerlandes",
    "href": "datenanreicherung.html#funktion-zur-ermittlung-des-künstlerlandes",
    "title": "4  Datenanreicherung",
    "section": "",
    "text": "Setzen des User-Agent: Zuerst wird ein User-Agent für die MusicBrainz API gesetzt. Dies ist notwendig, um die Anfragen an die API zu authentifizieren (Account ist notwendig).\nSuchanfrage an MusicBrainz: Die Funktion sucht nach dem übergebenen Künstlernamen.\nRückgabe des Landes: Wenn ein Künstler gefunden wird, gibt die Funktion das Land des Künstlers zurück.\nFehlerbehandlung: Im Falle eines Fehlers bei der Anfrage oder der Verarbeitung der Daten wird eine Fehlermeldung zurückgegeben.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Datenanreicherung</span>"
    ]
  },
  {
    "objectID": "datenanreicherung.html#anreicherung-des-datensatzes-mit-den-künstlerländern",
    "href": "datenanreicherung.html#anreicherung-des-datensatzes-mit-den-künstlerländern",
    "title": "4  Datenanreicherung",
    "section": "4.2 Anreicherung des Datensatzes mit den Künstlerländern",
    "text": "4.2 Anreicherung des Datensatzes mit den Künstlerländern\nDer Datensatz wurde mit den Ländern der Künstler angereichert, indem die zuvor definierte Funktion verwendet wurde, um das Land für jeden Künstler abzufragen und dem DataFrame hinzuzufügen. Das ganze habe ich mit einer for-Schleife realisiert.\n\n\"\"\"\nartist_country_list = []\n\nfor artist in artist_list:\nartist_country_list.append(find_artist_country(artist))\n\ndf['artist_country'] = artist_country_list\n\n\"\"\"\n\n\"\\nartist_country_list = []\\n\\nfor artist in artist_list:\\nartist_country_list.append(find_artist_country(artist))\\n\\ndf['artist_country'] = artist_country_list\\n\\n\"\n\n\nDa die Datenbank leider nicht alle Künstler kannte, kam es in manchen Spalten zu Errors. Diese habe ich im Anschluss entfernt.\n \nDiese Datenanreicherung ermöglicht nun eine geografische Analyse der Künstlerstandorte und unterstützt die visuelle Darstellung der globalen Verteilung der Top-Künstler. Darauf basierend ist nun die Darstellung einer Map möglich.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Datenanreicherung</span>"
    ]
  },
  {
    "objectID": "datenexploration.html",
    "href": "datenexploration.html",
    "title": "5  Datenexploration",
    "section": "",
    "text": "5.1 Verwendete Werkzeuge und Bibliotheken\nFür die Datenexploration habe ich verschiedene Bibliotheken verwendet. Für Korrelationsmatrizen und Histogramme habe ich die Python Visualisierungsbibliothek Seaborn benutzt, weil ich hier schon Vorkenntnisse besaß und es in der Datenexploration nur darum geht, Zusammenhänge zu finden und nicht um eine ansprechende Visualisierung. Des Weiteren habe ich pandas benutzt, um Auffälligkeiten zu finden.\nJedoch habe ich auch hier “Mockups“ von ersten, meines Erachtens wichtigen Erkenntnissen mit Altair erstellt. Darauf gehe ich aber erst im nächsten Kapitel ein.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenexploration</span>"
    ]
  },
  {
    "objectID": "datenexploration.html#vorgehen",
    "href": "datenexploration.html#vorgehen",
    "title": "5  Datenexploration",
    "section": "5.2 Vorgehen",
    "text": "5.2 Vorgehen\nDas Ziel dieser Analyse ist, wie mehrfach schon erwähnt, eine Art Geheimformel für einen erfolgreichen Song herauszufinden.\nDafür habe ich zuerst die Verteilung musikalischen Merkmale der meistgestreamtesten Songs auf Spotify angeschaut. Dies habe ich mit der python-Bibliothek seaborn gemacht, da es hierbei noch nicht um eine ansprechende Visualisierung geht und ich diese Darstellung mit seaborn leichter finde, als mit altair. In den folgenden Plots sind die Anzahl der Songs mit der jeweiligen Ausprägung des musikalischen Merkmals zu sehen. Als Maßstab habe ich hier die Anzahl der Songs genommen, da der Datensatz bereits die erfolgreichsten Songs im Jahre 2023 enthält.\n\n\n\nHistogramme anhand der musikalischen Merkmale\n\n\n\nUm trotzdem Auffälligkeiten zwischen der Anzahl der Streams und den musikalischen Merkmalen zu finden, habe ich eine Heatmap erstellt. Diese enthält, wie Sie unten sehen, die einzelenen musikalischen Merkmale und als Label die Streams.\n\n\n\nHeatmap\n\n\n\nNatürlich habe ich mir auch noch die anderen Merkmale angschaut, mithilfe der value_counts() builtin function von Pandas habe ich die Anzahl der Top-Songs nach der Tonart und des Keys angeschaut:\nTonart\n\n\n\nmode\nAnzahl der Top-Songs\n\n\n\n\nMajor\n445\n\n\nMinor\n351\n\n\n\nKey\n\n\n\nkey\nAnzahl der Top-Songs\n\n\n\n\nC#\n114\n\n\nG\n87\n\n\nG#\n85\n\n\nF\n81\n\n\nB\n76\n\n\nD\n74\n\n\nA\n71\n\n\nF#\n68\n\n\nE\n55\n\n\nA#\n55\n\n\nD#\n30\n\n\n\n\nDanach bin ich weg von den musikalischen Merkmalen und hin zu den zeitlichen und geografischen. Wann ist der beste Zeitpunkt, einen Song zu releasen? Aus welchem Land kommen die meisten Top-Künstler? Auch hier konnte ich mit der pandas builtin value_counts() wichtige erste Informationen sammeln:\nReleasezeitpunkt\n\n\n\nreleased_month\nAnzahl der Top-Songs\n\n\n\n\n5\n112\n\n\n1\n112\n\n\n6\n75\n\n\n3\n69\n\n\n11\n66\n\n\n12\n63\n\n\n4\n62\n\n\n10\n58\n\n\n9\n48\n\n\n7\n47\n\n\n2\n45\n\n\n8\n39\n\n\n\nAnzahl der Künstler nach Herkunftsland\n\n\n\nartist_country\nAnzahl der Künstler\n\n\n\n\nUnited States\n354\n\n\nPuerto Rico\n62\n\n\nUnited Kingdom\n57\n\n\nSouth Korea\n54\n\n\nCanada\n43\n\n\nColombia\n36\n\n\nEngland\n30\n\n\nMexico\n28\n\n\nBrazil\n16\n\n\nArgentina\n12",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenexploration</span>"
    ]
  },
  {
    "objectID": "datenexploration.html#ergebnisse-der-exploration",
    "href": "datenexploration.html#ergebnisse-der-exploration",
    "title": "5  Datenexploration",
    "section": "5.3 Ergebnisse der Exploration",
    "text": "5.3 Ergebnisse der Exploration\nWie in den Histogrammen und in der Heatmap zu sehen ist, haben viele Top-Songs ähnliche Merkmalsausprägungen. Besonders stechen diese rechtsschiefen Verteilungen ins Auge:\n\nspeechiness\ninstrumentalness\n\nAber auch die eher normalverteilten Merkmale sollte man beachten:\n\nenergy\ndanceability\n\nAuch bei der Tonart und des Keys konnte ich Auffälligkeiten feststellen. Die meisten Top-Songs haben die Tonart Major und den Key C#\nDer Releasezeitpunkt sollte auch ordentlich durchdacht werden. Im Janaur und Mai werden die meisten Songs released, im August wurden fast 3-mal weniger Songs released.\nEine weitere interessante Information ist, dass mit großem Abstand die meisten Top-Künstler aus den USA kommen.\nMit diesen Erkenntnissen kann ich nun ansprechende Visualisierungen gestalten. Wie ich das gemacht habe erfahren Sie im nächsten Kapitel.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenexploration</span>"
    ]
  },
  {
    "objectID": "datenvisualisierung.html",
    "href": "datenvisualisierung.html",
    "title": "6  Datenvisualisierung",
    "section": "",
    "text": "6.1 Grundlegendes Design\nUm ein durchgehendes Design zu ermöglichen, habe ich zuerst Konfigurationsparameter für Altair Plots erstellt. Diese sind so gut wie gleich in den verschiedenen Diagrammtypen:\n\"\"\"\n.properties(\n    title={'text': 'Beispiel', 'dy': -20},\n    background='#F5F5F5',\n    width=600,\n    height=400\n).configure_title(\n    fontSize=25,\n    anchor='start'\n).configure_axis(\n    labelFontSize=14,\n    titleFontSize=20,\n    titleColor='gray',\n    labelColor='gray',\n    titlePadding=12,\n    grid=False\n).configure_legend(\n    titleFontSize=16,\n    labelFontSize=14\n).configure_view(\n    strokeWidth=0,\n).configure_axisX(\n    labelAngle=0,\n    titleAnchor='start'\n).configure_axisY(\n    titleAnchor='end'\n)\n\n\"\"\"\n\n\"\\n.properties(\\n    title={'text': 'Beispiel', 'dy': -20},\\n    background='#F5F5F5',\\n    width=600,\\n    height=400\\n).configure_title(\\n    fontSize=25,\\n    anchor='start'\\n).configure_axis(\\n    labelFontSize=14,\\n    titleFontSize=20,\\n    titleColor='gray',\\n    labelColor='gray',\\n    titlePadding=12,\\n    grid=False\\n).configure_legend(\\n    titleFontSize=16,\\n    labelFontSize=14\\n).configure_view(\\n    strokeWidth=0,\\n).configure_axisX(\\n    labelAngle=0,\\n    titleAnchor='start'\\n).configure_axisY(\\n    titleAnchor='end'\\n)\\n\\n\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "datenvisualisierung.html#grundlegendes-design",
    "href": "datenvisualisierung.html#grundlegendes-design",
    "title": "6  Datenvisualisierung",
    "section": "",
    "text": "6.1.1 Allgemeine Eigenschaften\n\n.properties(): Allgemeine Eigenschaften des Diagramms.\n\ntitle: Legt den Titel des Diagramms fest.\ndy definiert die vertikale Verschiebung\nbackground: Hintergrundfarbe des Diagramms.\nwidth: Bestimmt die Breite des Diagramms in Pixeln.\nheight: Bestimmt die Höhe des Diagramms in Pixeln.\n\n\n\n\n6.1.2 Titelkonfiguration\n\n.configure_title(): Anpassungen für den Diagrammtitel.\n\nfontSize: Die Schriftgröße des Titels in Pixeln.\nanchor: Die Ausrichtung des Titels.\n\n\n\n\n6.1.3 Achsenkonfiguration\n\n.configure_axis(): onfiguration für beide Achsen (X & Y).\n\nlabelFontSize: Schriftgröße der Achsenbeschriftungen.\ntitleFontSize: Schriftgröße des Achsentitels.\ntitleColor und labelColor: Die Farbe des Achsentitels und der Beschriftungen.\ntitlePadding: Der Abstand zwischen dem Achsentitel und den Achsenbeschriftungen.\ngrid: Steuert die Anzeige des Netztes\n\n\n\n\n6.1.4 Legendenkonfiguration\n\n.configure_legend(): Passt das Aussehen der Legende an.\n\ntitleFontSize: Die Schriftgröße des Legendentitels.\nlabelFontSize: Die Schriftgröße der Legendenbeschriftungen.\n\n\n\n\n6.1.5 Ansichtskonfiguration\n\n.configure_view(): Konfiguation der Ansicht.\n\nstrokeWidth: Die Breite des Rahmens um das Diagramm.\n\n\n\n\n6.1.6 Spezifische Achsenkonfigurationen\n\n.configure_axisX() und .configure_axisY(): Spezifische Konfigurationen für die X- und Y-Achse.\n\nlabelAngle: Der Winkel der Achsenbeschriftungen auf der X-Achse. 0 bedeutet eine horizontale Ausrichtung.\ntitleAnchor: Die Ausrichtung des Achsentitels.\n\n\n\nBeachte: Die Hintergrundfarbe, Schriftgröße und die width und height können in späteren Darstellungen in der quarto-Präsentation oder in dem Dashboard variieren.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "datenvisualisierung.html#barplots",
    "href": "datenvisualisierung.html#barplots",
    "title": "6  Datenvisualisierung",
    "section": "6.2 Barplots",
    "text": "6.2 Barplots\nFür die Erstellung von Barplots sind meiner Meinung nach die Anzahl der Songs nach Tonart und Keys geeignet, da man mit einem Barplot perfekt Unterschiede in verschiedenen Kategorien aufzeigen kann.\nTonart:\nDafür habe ich zuerst einen Barplot mit den zwei verschiedenen Tonarten auf der X-Achse erstellt. Um den Unterschied besser aufzuzeigen, habe ich die Skalierung auf der Y-Achse geändert und eine Linie auf der Höhe des Maximalwerts platziert. Das ganze habe ich mit der ‘alt.layer()’ Funktion erreicht, die die Linie und den Plot layert.\n\n\n\nAnzahl der Top-Songs nach Tonart\n\n\nKeys:\nHierfür habe ich einen Barplot mit den verschiedenen Keys auf der X-Achse erstellt. Auch hier habe ich, um den Unterschied besser aufzuzeigen, die Skalierung auf der Y-Achse geändert. Außerdem habe ich wieder eine Linie durch den Maximalwert gezogen und eine gestrichelte Linie durch den Minimalwert. Um diese Linien und somit den Unterschied besser hervorzuheben, habe ich dem Barplot eine geringere opacity gegeben. Auch hier habe ich wieder mit ‘alt.layer()’ gearbeitet.\n\n\n\nAnzahl der Ø Streams nach Key",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "datenvisualisierung.html#line-chart",
    "href": "datenvisualisierung.html#line-chart",
    "title": "6  Datenvisualisierung",
    "section": "6.3 Line-Chart",
    "text": "6.3 Line-Chart\nEin Liniendiagramm ist ideal, um die Anzahl der Song-Veröffentlichungen pro Monat darzustellen, da es die zeitliche Entwicklung und Trends klar hervorhebt. Es ermöglicht ein einfaches Erkennen von Mustern, wie z.B. saisonale Schwankungen oder Trends.\nFür die Erstellung dieses Diagramms habe ich zuerst die Release-Monate, die in dem Datensatz von 1 bis 12 angegeben waren, auf die Monatsabkürzungen gemapped. Diese stellen die X-Achse dar, auf der Y-Achse war die Anzahl der veröffentlichten Songs in diesem Monat abgebildet. Um die Unterschiede hervorzuheben, habe ich die Extremwerte mit Punkten und senkrechten gestrichelten Linien versehen. Dafür habe ich verschieden Plots erstellt und diese dann mit alt.layer() zusammengefügt.\n\n\n\nAnzahl der Veröffentlichungen nach Monat",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "datenvisualisierung.html#scatter-plot",
    "href": "datenvisualisierung.html#scatter-plot",
    "title": "6  Datenvisualisierung",
    "section": "6.4 Scatter-Plot",
    "text": "6.4 Scatter-Plot\nIch habe mich für ein Streudiagramm entschieden, um die Beziehung zwischen Speechiness und der Anzahl der Streams darzustellen, weil dabei, Muster und Korrelationen zwischen diesen beiden Variablen zu erkennen sind. Dieser Plot veranschaulicht besonders gut, wie die Menge der gesprochenen Worte in einem Song (Speechiness) mit der Anzahl der erfolgreichen Songs, mit diesem Speechiness-Wert zusammenhängt.\nUm diesen Scatter-Plot zu erstellen, habe ich zunächst die Daten nach der Speechiness gruppiert und die Anzahl der Songs für jeden Speechniess-Wert gezählt. Danach habe ich Songs, die mehr als 40% Speechiness haben, aussortiert, um den Fokus auf dem relevanten Bereich zu belassen. Anschließend habe ich diese gefilterten Daten benutzt, um ein lineares Regressionsmodell zu trainieren (sklearn). Diese Vorhersage habe ich dann in einem DataFrame gespeichert.\nDaraufhin habe ich mit Altair die Regressionslinie und den Scatter-Plot erstellt und diese wieder mit alt.layer() zusammengefügt. Um die Regressionslinie hervorzuheben, habe ich die opacity des Scatter-Plots angepasst.\n\n\n\nBeziehung zwischen Anzahl der Songs und der Speechiness",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "datenvisualisierung.html#distribution-plot",
    "href": "datenvisualisierung.html#distribution-plot",
    "title": "6  Datenvisualisierung",
    "section": "6.5 Distribution-Plot",
    "text": "6.5 Distribution-Plot\nIch habe mich dazu entschieden, die Anzahl der Songs pro Energie-Kategorie in einem Verteilungsdiagramm darzustellen, weil es mir ermöglicht, die Verteilung und die zentrale Tendenz der Daten auf einen Blick zu erfassen. So kann ich erkennen, in welchen Energiebereichen die meisten Songs veröffentlicht werden und eventuelle Ausreißer oder Trends sofort identifizieren.\nDafür habe ich zuerst die Energy-Werte gruppiert und von 0 bis 100 in 10 Kategorien aufgeteilt, mit der durchschnittlichen Anzahl der Songs pro Kategorie. Daraufhin habe ich nun 2 Charts erstellt, ein Histogramm, welches das Ergebnis in ‘Balkenform’ angibt und ein Liniendiagramm mit dem Prop interpolate='monotone' für eine glatte Linie.\nDiese beiden Plots habe ich wieder mit der alt.layer() Funktion zusammengefügt und dem Histogramm etwas weniger opacity gegeben, um die Linie etwas hervorzuheben.\n\n\n\nØ Anzahl der Songs nach Energy",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "datenvisualisierung.html#map",
    "href": "datenvisualisierung.html#map",
    "title": "6  Datenvisualisierung",
    "section": "6.6 Map",
    "text": "6.6 Map\nFür die Map habe ich die Geopandas Bibliothek verwendet, die sich sehr gut für die Verarbeitung von geografischen Daten eignet. Jedoch musste ich zuerst die von mir angereicherten Herkunftsländer in dem Datensatz mappen, da sie in der verwendeten Bibliothek zum Teil anders hießen. Danach habe ich die Anzahl der Künstler pro Land gezählt und in einem DataFrame gespeichert. Dann wurden die Geopandas-Daten und mein DataFrame zusammengeführt, wobei die Anzahl der Künstler pro Land als zusätzliche Information hinzugefügt wurde.\nMit Altair habe ich dann eine Map erstelt, und die Länder entsprechend ihrer Künstler-Anzahl eingefärbt. Da es einen starken Ausreißer, die USA gab, habe ich eine logarithmische Skala verwendet, um die Unterschiede sichtbarer zu machen.\n\n\n\nAnzahl Top-Künstler nach Herkunftsland\n\n\n\nNun hatte ich die grundlegenden Charts erstellt und ich konnte mit der Erstellung der Präsentation und des Dashboards beginnen.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "quarto_prasi.html",
    "href": "quarto_prasi.html",
    "title": "7  Quarto Präsentation",
    "section": "",
    "text": "7.1 Desgin\nIch habe mich für ein dunkles Design entschieden, welches ich mit dem frei verfügbaren Theme “dark” erreichen konnte. Außerdem habe ich eine custom scss Datei erstellt, in der ich die Größen und das Alignment der Überschriften und des Footers bestimmt habe:\nscss:\n\"\"\"\n\n/*-- scss:defaults --*/\n// Hier können Sie Standardwerte für Variablen definieren.\n\n/*-- scss:rules --*/\n// Hier schreiben Sie Ihre Haupt-Style-Regeln.\n.reveal {\n    h3 {\n        font-size: 70px;\n    }\n\n    h4 {\n        font-size: 40px;\n    }\n\n    h2 {\n        font-size: 100px;\n    }\n\n    h1 {\n        text-align: center;\n        font-size: 200px;\n    }\n\n\n\n    // Weitere Style-Regeln...\n}\n\n\n.footer {\n    text-align: left;\n}\n\n\n\n\"\"\"\n\n'\\n\\n/*-- scss:defaults --*/\\n// Hier können Sie Standardwerte für Variablen definieren.\\n\\n/*-- scss:rules --*/\\n// Hier schreiben Sie Ihre Haupt-Style-Regeln.\\n.reveal {\\n    h3 {\\n        font-size: 70px;\\n    }\\n\\n    h4 {\\n        font-size: 40px;\\n    }\\n\\n    h2 {\\n        font-size: 100px;\\n    }\\n\\n    h1 {\\n        text-align: center;\\n        font-size: 200px;\\n    }\\n\\n\\n\\n    // Weitere Style-Regeln...\\n}\\n\\n\\n.footer {\\n    text-align: left;\\n}\\n\\n\\n\\n'\nAußerdem habe ich die Breite für Slides benutzerdefiniert angepasst, mit dem Ziel, dass die Diagramme immer noch angemessen angezeigt werden, wenn die Slide in Columns aufgeteilt wird:\nUm eine konsistente Farbauswahl für die (Achsen-)Titel zu erzeugen, die zu dem dunklen Hintergrund passt, habe ich Farben definiert:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Quarto Präsentation</span>"
    ]
  },
  {
    "objectID": "quarto_prasi.html#desgin",
    "href": "quarto_prasi.html#desgin",
    "title": "7  Quarto Präsentation",
    "section": "",
    "text": "Breite: 2000\nHöhe: 960\n\n\n\nTitelfarbe: rgba(230, 230, 230, 0.7)\nY-Achse-Titel&Label: rgba(230, 230, 230, 0.5)\nX-Achse-Titel&Label: rgba(224, 224, 224, 0.3)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Quarto Präsentation</span>"
    ]
  },
  {
    "objectID": "quarto_prasi.html#vorgehen",
    "href": "quarto_prasi.html#vorgehen",
    "title": "7  Quarto Präsentation",
    "section": "7.2 Vorgehen",
    "text": "7.2 Vorgehen\nNachdem das Design stand, habe ich meine erstellten Visualisierungen in die jeweiligen Slides eingebaut. In meinem Vorgehen wurden zunächst die Base Charts ohne layering präsentiert und dabei die einzelnen Merkmale und Bestandteile des Diagramms erläutert. Im Anschluss dann mit Layering, um auf die Ergebnisse besser einzugehen. Um Text neben den Diagrammen einzubauen, wurden die Slides in Columns aufgeteilt.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Quarto Präsentation</span>"
    ]
  },
  {
    "objectID": "streamlit_dashboard.html",
    "href": "streamlit_dashboard.html",
    "title": "8  Streamlit Dashboard und Report",
    "section": "",
    "text": "8.1 Design, Aufbau und Beschreibung der Funktionalität des Dashboards\nAn dem Design musste ich nicht viel ändern, da ein Streamlit Dashboard von Haus aus meiner Meinung nach ziemlich gut aussieht. Ich habe in den meisten Fällen nur das layout auf wide gesetzt, um mehrere Visualisierungen nebeneinander darstellen zu können. Außerdem wurde, wenn Charts in einem kurzen Text erklärt wurden, dieser Text mit derselben Farbe des Diagrammtitels versehen.\nFür den Aufbau des Dashboards habe ich eine Multipage-App gewählt. In Streamlit ist dies relativ einfach. Die verschiedenen Dateinamen müssen mit der Nummer der Page anfangen.\nIch habe zuerst eine Info-Page erstellt, in dieser erhält der User einen Überblick über mein Projekt und meine verwendeten Daten.\nZum Einstieg habe ich zwei Balkendiagramme der Top-10 Songs und der Top-10 Künstler dargestellt. Um eine Interaktivität zu gewähren, wurde dem User eine Auswahl gegeben. Hier kann er seine Lieblingskünstler auswählen und es wird automatisch ein Pie-Chart erstellt, mit der Anzahl der Streams der ausgewählten Künstler. Das wurde mit einem Filtermechanismus umgesetzt, der den DataFrame nach den ausgewählten Künstlern filtert. Dazu habe ich eine If-Abfrage erstellt, um zu prüfen, ob der User mehr als 12 Künstler ausgewählt hat. Ist dies der Fall, dann wird eine Fehlermeldung angezeigt.\nIn der nächsten Page geht es um den Einfluss der Tonart und des Keys auf den Erfolg des Songs. Hier sind die beiden Diagramme, nach Tonart und nach Key zu sehen. In der Sidebar kann der User nach Tonart und nach Key filtern. Die Diagramme werden dabei automatisch angepasst. Das heißt, wenn der User als Filtermöglichkeit für die Tonart ‘Major’ wählt, dann wird in dem Tonartdiagramm nur Major angezeigt. Das Keys-Diagramm passt sich dahingehend an, dass nur die durschnittlichen Streams nach Key für die jeweilige Tonart, in diesem Beispiel für ‘Major’ angezeigt werden. Dieser Vorgang läift gleich, wenn der User nach Keys filtert. Unten werden dem User abhängig von seiner Auswahl die Top-5 Songs nach Streams angezeigt. Dies wurde auch hier mit einem Filtermechanismus erschaffen.\nDie nächste Page behandelt den Einfluss des Veröffentlichungsmonats. Hier habe ich nur einen kleinen Text und zwei Buttons implementiert. Wenn der User den Button ‚Diagrammdemo starten‘ klickt, wird eine schrittweise Demonstration eingeleitet. Wenn der User auf ‘mehr Details anzeigen’ klickt, dann werden ihm die Extrempunkte markiert und ein kleiner Text erscheint. Das wurde mit einer for-schleife erreicht. Nach jeder Iteration wird dem Dataframe ein Monat hinzugefügt. Um den Vorgang langsamer und somit anschaulicher zu gestalten, wurde die Time Bibliothek von Python benutzt: time.sleep(0.25), damit wird eine viertel Sekunde gewartet, bis der nächste Monat zum DataFrame hinzugefügt wird.\nIn der nächsten Page wird der Einfluss von den Audio-Merkmalen auf die Songpopularität betrachtet. Hier werden vier verschiedene Scatter-Plots mit Regressionslinie gezeigt. Die betrachteten Merkmale sind hier Speechiness, Liveness, Instrumentalness und Accousticness. Hier kann der User in der Sidebar zwischen der Anzeige von Regressionslinie und Scatter-Plot, nur der Regressionslinie und nur dem Scatter-Plot wählen. Außerdem kann er die Y-Achse anpassen, ob sie nach den Streams oder nach der Anzahl der Songs misst. Um diese Funktion zu ermöglichen, habe ich zwei Funktionen erstellt, eine erstellt dabei den Plot anhand der Anzahl der Songs, die Andere anhand der Anzahl der Streams. Beide haben die zwei Parameter ‘merkmal’ und ‘anzeige’. Um die Charts nun konditionell anzeigen zu können, habe ich If-Statements genutzt.\nDie nächste Page beschreibt, wie tanzbar und wie energetisch ein Song sein sollte. Diese ist etwas simpler gehalten. Hier kann der User in der Sidebar zwischen zwei Merkmalen wählen, der Energy und der Danceability. So wird der Distribution-Plot mit dem ausgewählten Merkmal angezeigt. Für die Umsetzung wurde mit einem einfachen If-Statement gearbeitet.\nDie letzte inhaltlich relevante Page handelt von der Herkunft der Top-Künstler. Diese ist auch relativ simpel aufgebaut. Die Map zeigt die Anzahl der Künstler nach Ländern, in der Sidebar kann der User Länder auswählen. Wenn der User eine Auswahl trifft, dann werden nur diese Länder in der Map angezeigt und unten wird zusätzlich ein Barplot mit den ausgewählten Ländern nach Top-Künstlern erstellt. Um diese Funktionalität zu erreichen, wurde der Dataframe anhand von Eingaben in der Sidebar gefiltert.\nZuletzt wurde eine Kontaktpage erstellt. Hier findet der User meine Kontaktdaten.\nFalls sie sich das Dashboard anschauen möchten, finden sie hier den Link:",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Streamlit Dashboard und Report</span>"
    ]
  },
  {
    "objectID": "streamlit_dashboard.html#design-aufbau-und-beschreibung-der-funktionalität-des-dashboards",
    "href": "streamlit_dashboard.html#design-aufbau-und-beschreibung-der-funktionalität-des-dashboards",
    "title": "8  Streamlit Dashboard und Report",
    "section": "",
    "text": "Dashboard",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Streamlit Dashboard und Report</span>"
    ]
  },
  {
    "objectID": "streamlit_dashboard.html#erstellung-des-reports",
    "href": "streamlit_dashboard.html#erstellung-des-reports",
    "title": "8  Streamlit Dashboard und Report",
    "section": "8.2 Erstellung des Reports",
    "text": "8.2 Erstellung des Reports\nFür die Erstellung des Reports habe ich die wichtigsten und aussagekräftigsten Graphen meines Projekts genutzt. Da die maximale Präsentationszeit bei 10 Minuten lag, musste ich mich in der Präsentation kurz halten und somit nur die wichtigsten Charts zeigen. Ich habe lediglich die beiden Graphen mit den Top-Künstlern und den Top-Songs weggelassen. Außerdem wurden für den Report die detaillierten (gelayerten) Charts verwendet. Diese habe ich mit Text versehen, um die wichtigsten Erkenntnisse meines Projekts nochmals klar darzustellen. Dazu habe ich über das jeweilige Diagramm einen kurzen Text, welcher erläutert, um was es in dem Graphen geht und was die Merkmale bedeuten, verfasst. Neben den Graphen wurden die Auffälligkeiten in ihnen erwähnt und unter ihnen eine Handlungsempfehlung. Diese Erkenntnisse wurden am Ende nochmals als Formel zusammengefasst.\nHier finden sie den Report:\n\nReport",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Streamlit Dashboard und Report</span>"
    ]
  },
  {
    "objectID": "herausforderungen.html",
    "href": "herausforderungen.html",
    "title": "9  Herausforderungen und Lösungen",
    "section": "",
    "text": "9.1 Datensatz und geografische Daten\nIch hatte wenig Probleme mit den Daten. Die Spalten hatten meiner Meinung nach gut verständliche Namen und der Rest der Data-Preparation war schnell erledigt. Jedoch ist mir im Laufe des Projekts aufgefallen, dass ich geografische Daten für die Erstellung einer Map brauche. So ist mir die Idee gekommen, das Herkunftsland des Künstlers hinzuzufügen. Manuell hätte dies sehr lange gedauert. Es musste eine andere Lösung her. Ich hab mich auf die Suche nach Musik-Apis begeben und bin fündig geworden. Anhand von Musicbrainz konnte ich, wie beschrieben in Kapitel 4, das Herkunftsland des Künstlers mit wenig Aufwand hinzufügen.\nDas hat sehr gut funktioniert, bis zur Erstellung der Map. Leider haben die Länderbezeichnungen der Musicbrainz Datenbank nicht mit denen der geopandas Bibliothek übereingestimmt. Aber auch hierfür habe ich eine Lösung gefunden. Ich habe eine Funktion geschrieben, welche die Länderbezeichnungen vergleicht und übereinstimmende oder fehlende Länder ausgibt.\nHier ist die Funktion:\n\"\"\"\n\n\ndef compare_country_names(df, country_list):\n\n    df_countries = set(df['name'].unique())\n    country_list_set = set(country_list)\n\n    # Finden der Übereinstimmungen und Nichtübereinstimmungen\n    matches = df_countries.intersection(country_list_set)\n    missing = df_countries.difference(country_list_set)\n\n    return matches, missing\n\n\n\n\"\"\"\n\n\"\\n\\n\\ndef compare_country_names(df, country_list):\\n\\n    df_countries = set(df['name'].unique())\\n    country_list_set = set(country_list)\\n\\n    # Finden der Übereinstimmungen und Nichtübereinstimmungen\\n    matches = df_countries.intersection(country_list_set)\\n    missing = df_countries.difference(country_list_set)\\n\\n    return matches, missing\\n\\n\\n\\n\"\nMithilfe dieser Funktion konnte ich meine Bezeichnungen mappen und somit eine Übereinstimmung erreichen.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Herausforderungen und Lösungen</span>"
    ]
  },
  {
    "objectID": "herausforderungen.html#visualisierungen",
    "href": "herausforderungen.html#visualisierungen",
    "title": "9  Herausforderungen und Lösungen",
    "section": "9.2 Visualisierungen",
    "text": "9.2 Visualisierungen\nDurch die einfache und verständliche Syntax von Altair, hatte ich kaum Probleme beim Erstellen der Visualisierungen. Lediglich bei der Erstellung der Map war es in meinem Fall etwas schwer, eine aussagekräftige Skalierung zu erhalten. Die Map stellt die Anzahl der Top-Künstler aus dem jeweiligen Land dar. Das Problem hierbei war, dass die USA als Ausreißer fast 300 Künstler mehr als das zweitplatzierte Land, England, hatte. Somit war es schwierig, eine Skala zu finden, die den Unterschied trotzdem ersichtlich macht. Ich habe es zuerst mit konditionellem Anzeigen versucht (alt.Condition), dies hat leider nicht funktioniert. Nach längerer Suche bin ich auf logarithmische Skalierung gekommen. Dies war sehr einfach in altair umzusetzen, ich musste lediglich type='log' in das Scale Prop von altair hinzufügen und schon waren die Unterschiede besser zu erkennen und das Problem war gelöst.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Herausforderungen und Lösungen</span>"
    ]
  },
  {
    "objectID": "herausforderungen.html#quarto-präsentation",
    "href": "herausforderungen.html#quarto-präsentation",
    "title": "9  Herausforderungen und Lösungen",
    "section": "9.3 Quarto Präsentation",
    "text": "9.3 Quarto Präsentation\nIm Großen und Ganzen kam ich gut mit Quarto zurecht.Probleme hatte ich nur mit dem Einbauen der Altair-Charts. Ich wollte einen dunklen Hintergrund und habe, wie in Kapitel 7 schon erwähnt, das Dark Theme benutzt. Nun war aber der weiße Hintergrund der Charts noch zu sehen und meines Wissens gibt es keine Funktion den Chart Transparent zu gestalten. Hierfür habe ich aber eine Lösung gefunden. Mithilfe eines Colorpickers konnte ich die Farbe des Hintergrunds herausfinden und in den background prop der Diagramme einsetzen. Diesen Colorpicker habe ich verwendet:\n\nColorpicker\n\nLeider hatte ich das Problem, dass die Diagramme in der HTML-Page manchmal nicht angezeigt worden sind. Ich habe mitbekommen, dass dieses Problem auch andere in diesem Kurs hatten. Dafür habe ich keine richtige Lösung gefunden, außer die HTML Datei via GitHub-Pages zu deployen. So wurden die Diagramme eigentlich immer angezeigt.\n\nDeployte html Datei meiner Präsentation\n\nDes Weiteren wurden bei mir manchmal verschiedene Aspekte aus gelayerten Charts nicht angezeigt. Zum Beispiel eine Linie durch den Maximalwert. Ich habe lange gebraucht, um das Problem zu lösen, da sie in den Jupyter Notebooks immer angezeigt worden sind. Das Problem war, dass selbst die Linie, welche nur statisch mit einer Steigung von 0 durch beispielsweise y=60 geht, einen Dataframe als Input braucht, um bei quarto angezeigt zu werden.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Herausforderungen und Lösungen</span>"
    ]
  },
  {
    "objectID": "herausforderungen.html#streamlit-dashboard",
    "href": "herausforderungen.html#streamlit-dashboard",
    "title": "9  Herausforderungen und Lösungen",
    "section": "9.4 Streamlit Dashboard",
    "text": "9.4 Streamlit Dashboard\nMit Streamlit hatte ich wirklich kaum Probleme, da die Syntax sehr einfach gehalten ist. Jedoch musste ich auf der ersten Page in den Diagrammen: “Top-10 Songs nach Streams” und “Top-10 Künstler nach Streams“ eine Anpassung vornehmen. Die Künstler und die Songnamen haben sich auf der X-Achse überschnitten, dies konnte ich aber durch einfaches Tauschen der Achsen lösen.\nDes Weitern musste ich mich für die Erstellung der Diagrammdemo, welche die Anzahl der veröffentlichten Songs pro Monat anzeigt, erstmal in den session_state in Streamlit einlesen. Dies war ein minder großes Problem.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Herausforderungen und Lösungen</span>"
    ]
  },
  {
    "objectID": "fazit.html",
    "href": "fazit.html",
    "title": "10  Fazit und Reflexion",
    "section": "",
    "text": "10.1 Projektergebnisse\nIm Rahmen des Projekts konnten umfangreiche und aufschlussreiche Informationen über die Musik und die Musikindustrie gewonnen werden. Im folgenden werden die zentralen Erkenntnisse des Projekts zusammengefasst dargelegt, einschließlich der entscheidenden Faktoren, die einen Song zum Erfolg führen können.\nDie Tonart und der Key eines Songs spielen eine große Rolle. Es ist darauf zu achten, dass die Tonart Major verwendet wird, das spricht für einen fröhlichen Klang. Außerdem sollte der Song den Key C# haben.\nEine Weitere wichtige Rolle spielt der Releasemonat des Songs. Die meisten Top-Songs wurden im Januar oder im Mai released. Im August wurden fast viermal so wenig Songs released wie in den beiden Top-Monaten.\nEine weitere Auffälligkeit ist, dass die meisten Top-Songs einen sehr geringen Sprechanteil haben. Also sollte sich der Musiker lieber auf Gesang und Melodie konzentrieren und weniger auf Sprechgesang bzw. Rap.\nZudem sollte der Song ein hohes Energieniveau haben und englisch- oder spanischsprachig sein.\nGeheimformel:\n\\[\n\\begin{align*}\n\\text{Erfolg} &= \\text{Tonart(Major)} + \\text{Key(C\\#)} \\\\\n&+ \\text{ReleaseMonat(Jan|Feb)} + \\text{Speechiness(3\\%)} \\\\\n&+ \\text{Energy(65\\%)} + \\text{Language(Englisch|Spanisch)}\n\\end{align*}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fazit und Reflexion</span>"
    ]
  },
  {
    "objectID": "fazit.html#reflexion",
    "href": "fazit.html#reflexion",
    "title": "10  Fazit und Reflexion",
    "section": "10.2 Reflexion",
    "text": "10.2 Reflexion\nDie Reflexion dieses Projekts zeigt, wie eine datengetriebene Analyse Erfolgsfaktoren von Musik zeigen kann. Jedoch während bestimmte Trends, wie die Veröffentlichung in bestimmten Monaten oder die Verwendung eines speziellen Keys, die Erfolgschancen eines Hits verbessern, ist es dennoch wichtig zu betonen, dass Musik viel mehr als eine Sammlung von Datenpunkten ist. Musik ist und bleibt eine Kunstform und dies sollte meiner Meinung nach auch so bleiben. Es wäre doch sehr schade, wenn sich alle Songs gleich anhören würden und die verschiedenen Genres miteinander verschmelzen.\nDeswegen sollte zu der Geheimformel des musikalischen Erfolgs noch Kreativität und musikalische Individualität hinzugefügt werden.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fazit und Reflexion</span>"
    ]
  }
]